/**
 * Transcript Database Module
 *
 * Uses sql.js (SQLite compiled to WASM) with IndexedDB persistence.
 * Provides a simple API for storing and retrieving transcripts.
 */

const DB_NAME = 'TranscriptDB';
const DB_VERSION = 1;
const STORE_NAME = 'sqlite';
const DB_KEY = 'database';

let db = null;
let SQL = null;

/**
 * Initialize the database
 * @returns {Promise<{success: boolean, storageType: string}>}
 */
async function initDatabase() {
    // Load sql.js
    SQL = await initSqlJs({
        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
    });

    // Try to load existing database from IndexedDB
    const savedData = await loadFromIndexedDB();

    if (savedData) {
        db = new SQL.Database(savedData);
        console.log('[DB] Loaded existing database from IndexedDB');
    } else {
        db = new SQL.Database();
        console.log('[DB] Created new database');
    }

    // Create schema if needed
    db.run(`
        CREATE TABLE IF NOT EXISTS transcripts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            video_id TEXT NOT NULL UNIQUE,
            title TEXT,
            channel_name TEXT,
            video_url TEXT,
            duration_seconds INTEGER,
            publish_date TEXT,
            captured_at TEXT DEFAULT (datetime('now')),
            raw_json TEXT,
            clean_text TEXT,
            language TEXT,
            is_auto_generated INTEGER DEFAULT 0,
            word_count INTEGER,
            summary TEXT,
            summary_generated_at TEXT,
            tags TEXT
        )
    `);

    // Migration: Add publish_date column if it doesn't exist (for existing databases)
    try {
        db.run(`ALTER TABLE transcripts ADD COLUMN publish_date TEXT`);
        console.log('[DB] Added publish_date column');
    } catch (e) {
        // Column already exists, ignore
    }

    db.run(`CREATE INDEX IF NOT EXISTS idx_captured_at ON transcripts(captured_at)`);
    db.run(`CREATE INDEX IF NOT EXISTS idx_video_id ON transcripts(video_id)`);

    // Save to persist schema
    await saveToIndexedDB();

    return { success: true, storageType: 'indexeddb' };
}

/**
 * Load database from IndexedDB
 */
function loadFromIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);

        request.onupgradeneeded = (event) => {
            const idb = event.target.result;
            if (!idb.objectStoreNames.contains(STORE_NAME)) {
                idb.createObjectStore(STORE_NAME);
            }
        };

        request.onsuccess = () => {
            const idb = request.result;
            const transaction = idb.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const getRequest = store.get(DB_KEY);

            getRequest.onsuccess = () => {
                idb.close();
                resolve(getRequest.result || null);
            };

            getRequest.onerror = () => {
                idb.close();
                resolve(null);
            };
        };
    });
}

/**
 * Save database to IndexedDB
 */
function saveToIndexedDB() {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve();
            return;
        }

        const data = db.export();
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);

        request.onupgradeneeded = (event) => {
            const idb = event.target.result;
            if (!idb.objectStoreNames.contains(STORE_NAME)) {
                idb.createObjectStore(STORE_NAME);
            }
        };

        request.onsuccess = () => {
            const idb = request.result;
            const transaction = idb.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.put(data, DB_KEY);

            transaction.oncomplete = () => {
                idb.close();
                resolve();
            };

            transaction.onerror = () => {
                idb.close();
                reject(transaction.error);
            };
        };
    });
}

/**
 * Save a transcript
 */
async function saveTranscript(data) {
    const {
        videoId, title, channelName, videoUrl, durationSeconds, publishDate,
        rawJson, cleanText, language, isAutoGenerated, wordCount
    } = data;

    // Check if exists
    const existing = db.exec(`SELECT id FROM transcripts WHERE video_id = ?`, [videoId]);

    if (existing.length > 0 && existing[0].values.length > 0) {
        // Update
        db.run(`
            UPDATE transcripts SET
                title = ?, channel_name = ?, video_url = ?, duration_seconds = ?,
                publish_date = ?, raw_json = ?, clean_text = ?, language = ?, is_auto_generated = ?,
                word_count = ?, captured_at = datetime('now')
            WHERE video_id = ?
        `, [title, channelName, videoUrl, durationSeconds, publishDate || null, rawJson, cleanText,
            language, isAutoGenerated ? 1 : 0, wordCount, videoId]);
    } else {
        // Insert
        db.run(`
            INSERT INTO transcripts
            (video_id, title, channel_name, video_url, duration_seconds, publish_date,
             raw_json, clean_text, language, is_auto_generated, word_count)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [videoId, title, channelName, videoUrl, durationSeconds, publishDate || null, rawJson, cleanText,
            language, isAutoGenerated ? 1 : 0, wordCount]);
    }

    await saveToIndexedDB();
    return { saved: true, videoId };
}

/**
 * Get a transcript by video ID
 */
function getTranscript(videoId) {
    const result = db.exec(`SELECT * FROM transcripts WHERE video_id = ?`, [videoId]);
    if (result.length === 0 || result[0].values.length === 0) {
        return null;
    }
    return rowToObject(result[0]);
}

/**
 * Get all transcripts
 */
function getAllTranscripts(limit = 50, offset = 0) {
    const result = db.exec(`
        SELECT id, video_id, title, channel_name, captured_at,
               language, is_auto_generated, word_count
        FROM transcripts
        ORDER BY captured_at DESC
        LIMIT ? OFFSET ?
    `, [limit, offset]);

    if (result.length === 0) return [];
    return result[0].values.map(row => rowToObjectWithColumns(row, result[0].columns));
}

/**
 * Delete a transcript
 */
async function deleteTranscript(videoId) {
    db.run(`DELETE FROM transcripts WHERE video_id = ?`, [videoId]);
    await saveToIndexedDB();
    return { deleted: true, videoId };
}

/**
 * Search transcripts
 */
function searchTranscripts(query) {
    const searchTerm = `%${query}%`;
    const result = db.exec(`
        SELECT id, video_id, title, channel_name, captured_at, word_count
        FROM transcripts
        WHERE title LIKE ? OR clean_text LIKE ? OR channel_name LIKE ?
        ORDER BY captured_at DESC
        LIMIT 50
    `, [searchTerm, searchTerm, searchTerm]);

    if (result.length === 0) return [];
    return result[0].values.map(row => rowToObjectWithColumns(row, result[0].columns));
}

/**
 * Get database statistics
 */
function getStats() {
    const result = db.exec(`
        SELECT
            COUNT(*) as total_transcripts,
            COALESCE(SUM(word_count), 0) as total_words,
            MIN(captured_at) as first_capture,
            MAX(captured_at) as last_capture
        FROM transcripts
    `);

    if (result.length === 0 || result[0].values.length === 0) {
        return { total_transcripts: 0, total_words: 0, first_capture: null, last_capture: null };
    }
    return rowToObjectWithColumns(result[0].values[0], result[0].columns);
}

/**
 * Export database as JSON
 */
function exportAsJson() {
    const result = db.exec(`SELECT * FROM transcripts ORDER BY captured_at DESC`);
    if (result.length === 0) return { transcripts: [], exportedAt: new Date().toISOString() };

    const transcripts = result[0].values.map(row => rowToObjectWithColumns(row, result[0].columns));
    return { transcripts, exportedAt: new Date().toISOString() };
}

/**
 * Export database as SQLite file
 */
function exportAsFile() {
    const data = db.export();
    return new Uint8Array(data);
}

/**
 * Import database from SQLite file
 */
async function importFromFile(arrayBuffer) {
    const data = new Uint8Array(arrayBuffer);
    db = new SQL.Database(data);
    await saveToIndexedDB();
    return { imported: true };
}

/**
 * Import transcripts from JSON
 */
async function importFromJson(jsonData) {
    const { transcripts } = jsonData;
    let imported = 0;

    for (const t of transcripts) {
        try {
            await saveTranscript({
                videoId: t.video_id,
                title: t.title,
                channelName: t.channel_name,
                videoUrl: t.video_url,
                durationSeconds: t.duration_seconds,
                publishDate: t.publish_date,
                rawJson: t.raw_json,
                cleanText: t.clean_text,
                language: t.language,
                isAutoGenerated: t.is_auto_generated === 1,
                wordCount: t.word_count
            });
            imported++;
        } catch (e) {
            console.warn('Failed to import transcript:', t.video_id, e);
        }
    }

    return { imported };
}

// Helper functions
function rowToObject(result) {
    if (!result || !result.values || result.values.length === 0) return null;
    return rowToObjectWithColumns(result.values[0], result.columns);
}

function rowToObjectWithColumns(row, columns) {
    const obj = {};
    columns.forEach((col, i) => {
        obj[col] = row[i];
    });
    return obj;
}

// Export the API
window.TranscriptDB = {
    init: initDatabase,
    save: saveTranscript,
    get: getTranscript,
    getAll: getAllTranscripts,
    delete: deleteTranscript,
    search: searchTranscripts,
    getStats: getStats,
    exportJson: exportAsJson,
    exportFile: exportAsFile,
    importFile: importFromFile,
    importJson: importFromJson
};
