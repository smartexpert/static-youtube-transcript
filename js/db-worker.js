/**
 * OPFS Database Worker
 *
 * Uses official sqlite-wasm with opfs-sahpool VFS for persistent storage.
 * This worker handles all database operations and communicates with the main thread via postMessage.
 *
 * opfs-sahpool benefits:
 * - No COOP/COEP headers required
 * - 3-4x faster than regular OPFS VFS
 * - Persistent storage beyond IndexedDB limits
 *
 * Limitation: Single connection only (one tab at a time)
 */

// Use the main entry point which re-exports sqlite3InitModule
const SQLITE_CDN = 'https://cdn.jsdelivr.net/npm/@sqlite.org/sqlite-wasm@3.51.1-build2/index.mjs';
const DB_PATH = '/transcripts.sqlite3';

let db = null;
let sqlite3 = null;

/**
 * Initialize SQLite with opfs-sahpool VFS
 */
async function initDatabase() {
    if (db) {
        return { success: true, storageType: 'opfs' };
    }

    try {
        // Dynamic import of sqlite-wasm
        const sqlite3Module = await import(SQLITE_CDN);
        sqlite3 = await sqlite3Module.default({
            print: console.log,
            printErr: console.error
        });

        console.log('[DB Worker] SQLite version:', sqlite3.version.libVersion);

        // Install opfs-sahpool VFS
        const poolUtil = await sqlite3.installOpfsSAHPoolVfs({
            initialCapacity: 4,
            clearOnInit: false
        });

        console.log('[DB Worker] opfs-sahpool VFS installed');

        // Open database
        db = new poolUtil.OpfsSAHPoolDb(DB_PATH);
        console.log('[DB Worker] Database opened:', db.filename);

        // Create schema
        db.exec(`
            CREATE TABLE IF NOT EXISTS transcripts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                video_id TEXT NOT NULL UNIQUE,
                title TEXT,
                channel_name TEXT,
                video_url TEXT,
                duration_seconds INTEGER,
                publish_date TEXT,
                captured_at TEXT DEFAULT (datetime('now')),
                raw_json TEXT,
                clean_text TEXT,
                language TEXT,
                is_auto_generated INTEGER DEFAULT 0,
                word_count INTEGER,
                summary TEXT,
                summary_generated_at TEXT,
                tags TEXT
            )
        `);

        db.exec(`CREATE INDEX IF NOT EXISTS idx_captured_at ON transcripts(captured_at)`);
        db.exec(`CREATE INDEX IF NOT EXISTS idx_video_id ON transcripts(video_id)`);

        console.log('[DB Worker] Schema ready');

        return { success: true, storageType: 'opfs' };
    } catch (err) {
        console.error('[DB Worker] Init failed:', err);
        throw err;
    }
}

/**
 * Save a transcript (insert or update)
 */
function saveTranscript(data) {
    const {
        videoId, title, channelName, videoUrl, durationSeconds, publishDate,
        rawJson, cleanText, language, isAutoGenerated, wordCount
    } = data;

    // Check if exists
    const existing = db.exec({
        sql: `SELECT id FROM transcripts WHERE video_id = ?`,
        bind: [videoId],
        returnValue: 'resultRows'
    });

    if (existing.length > 0) {
        // Update
        db.exec({
            sql: `
                UPDATE transcripts SET
                    title = ?, channel_name = ?, video_url = ?, duration_seconds = ?,
                    publish_date = ?, raw_json = ?, clean_text = ?, language = ?,
                    is_auto_generated = ?, word_count = ?, captured_at = datetime('now')
                WHERE video_id = ?
            `,
            bind: [title, channelName, videoUrl, durationSeconds, publishDate || null,
                   rawJson, cleanText, language, isAutoGenerated ? 1 : 0, wordCount, videoId]
        });
    } else {
        // Insert
        db.exec({
            sql: `
                INSERT INTO transcripts
                (video_id, title, channel_name, video_url, duration_seconds, publish_date,
                 raw_json, clean_text, language, is_auto_generated, word_count)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `,
            bind: [videoId, title, channelName, videoUrl, durationSeconds, publishDate || null,
                   rawJson, cleanText, language, isAutoGenerated ? 1 : 0, wordCount]
        });
    }

    return { saved: true, videoId };
}

/**
 * Get a transcript by video ID
 */
function getTranscript(videoId) {
    const rows = db.exec({
        sql: `SELECT * FROM transcripts WHERE video_id = ?`,
        bind: [videoId],
        returnValue: 'resultRows',
        rowMode: 'object'
    });

    return rows.length > 0 ? rows[0] : null;
}

/**
 * Get all transcripts (paginated)
 */
function getAllTranscripts(limit = 50, offset = 0) {
    return db.exec({
        sql: `
            SELECT id, video_id, title, channel_name, captured_at,
                   language, is_auto_generated, word_count
            FROM transcripts
            ORDER BY captured_at DESC
            LIMIT ? OFFSET ?
        `,
        bind: [limit, offset],
        returnValue: 'resultRows',
        rowMode: 'object'
    });
}

/**
 * Delete a transcript
 */
function deleteTranscript(videoId) {
    db.exec({
        sql: `DELETE FROM transcripts WHERE video_id = ?`,
        bind: [videoId]
    });
    return { deleted: true, videoId };
}

/**
 * Search transcripts
 */
function searchTranscripts(query) {
    const searchTerm = `%${query}%`;
    return db.exec({
        sql: `
            SELECT id, video_id, title, channel_name, captured_at, word_count
            FROM transcripts
            WHERE title LIKE ? OR clean_text LIKE ? OR channel_name LIKE ?
            ORDER BY captured_at DESC
            LIMIT 50
        `,
        bind: [searchTerm, searchTerm, searchTerm],
        returnValue: 'resultRows',
        rowMode: 'object'
    });
}

/**
 * Get database statistics
 */
function getStats() {
    const rows = db.exec({
        sql: `
            SELECT
                COUNT(*) as total_transcripts,
                COALESCE(SUM(word_count), 0) as total_words,
                MIN(captured_at) as first_capture,
                MAX(captured_at) as last_capture
            FROM transcripts
        `,
        returnValue: 'resultRows',
        rowMode: 'object'
    });

    return rows.length > 0 ? rows[0] : {
        total_transcripts: 0,
        total_words: 0,
        first_capture: null,
        last_capture: null
    };
}

/**
 * Export all transcripts as JSON
 */
function exportAsJson() {
    const transcripts = db.exec({
        sql: `SELECT * FROM transcripts ORDER BY captured_at DESC`,
        returnValue: 'resultRows',
        rowMode: 'object'
    });

    return {
        transcripts,
        exportedAt: new Date().toISOString()
    };
}

/**
 * Import transcripts from JSON
 */
function importFromJson(jsonData) {
    const { transcripts } = jsonData;
    let imported = 0;

    for (const t of transcripts) {
        try {
            saveTranscript({
                videoId: t.video_id,
                title: t.title,
                channelName: t.channel_name,
                videoUrl: t.video_url,
                durationSeconds: t.duration_seconds,
                publishDate: t.publish_date,
                rawJson: t.raw_json,
                cleanText: t.clean_text,
                language: t.language,
                isAutoGenerated: t.is_auto_generated === 1,
                wordCount: t.word_count
            });
            imported++;
        } catch (e) {
            console.warn('[DB Worker] Failed to import:', t.video_id, e);
        }
    }

    return { imported };
}

/**
 * Export database as binary (for backup)
 */
function exportAsFile() {
    // For opfs-sahpool, we export as SQL statements
    const transcripts = db.exec({
        sql: `SELECT * FROM transcripts ORDER BY captured_at DESC`,
        returnValue: 'resultRows',
        rowMode: 'object'
    });

    // Return as JSON (binary export not straightforward with opfs-sahpool)
    return JSON.stringify({ transcripts, exportedAt: new Date().toISOString() });
}

// Message handlers
const handlers = {
    init: initDatabase,
    save: (args) => saveTranscript(args[0]),
    get: (args) => getTranscript(args[0]),
    getAll: (args) => getAllTranscripts(args[0], args[1]),
    delete: (args) => deleteTranscript(args[0]),
    search: (args) => searchTranscripts(args[0]),
    getStats: () => getStats(),
    exportJson: () => exportAsJson(),
    exportFile: () => exportAsFile(),
    importJson: (args) => importFromJson(args[0])
};

// Listen for messages from main thread
self.onmessage = async (event) => {
    const { id, method, args = [] } = event.data;

    try {
        const handler = handlers[method];
        if (!handler) {
            throw new Error(`Unknown method: ${method}`);
        }

        const result = await handler(args);
        self.postMessage({ id, result });
    } catch (error) {
        console.error('[DB Worker] Error:', method, error);
        self.postMessage({ id, error: error.message });
    }
};

console.log('[DB Worker] Ready');
